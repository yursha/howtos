= Ruby
:toc:
:toc-placement!:

toc::[]

[[scripts]]
scripts
-------
`#!/usr/bin/env ruby`


[[modules]]
modules
-------

Ruby has built-in modules.

[[printing]]
printing
--------

[source, ruby]
....
puts "Hello, world!"

# with string interpolation
name = "Maria"
puts "Hello, #{name}!"
....

[[naming-conventions]]
Naming conventions
------------------

Ruby enforces some naming conventions. If an identifier starts with a capital letter, it is a constant (constants can still be modified producing a warning). If it starts with a dollar sign `$`, it is a global variable. If it starts with `@`, it is an instance variable. If it starts with `@@`, it is a class variable.


[[control-flow]]
Control flow
------------

[source,ruby]
....
# iteration
some_list.each do |this_item|
  # We're inside the block.
  # deal with this_item.
end

# ternary operator
z = if x < y
      true
    else
      false
    end
....

[[strings]]
Strings
-------

Internalized strings are called *symbols*.

[source,ruby]
....
:george  # symbol
"george" # string
....

Whenever you use a new String, Ruby allocates memory for it.

[[methods]]
Methods
-------

[source, ruby]
....
def hi
  puts "Hello World!"
end

def hello(name)
  puts "Hello #{name}!"
end

def bonjur(name = "World")
  puts "Hello #{name.capitalize}!"
end

hi             # Hello World!
hello "Maria"  # Hello Maria!
bonjur         # Hello World!
bonjur "Maria" # Hello Maria!
....

[[keyword-args]]
Keyword arguments
~~~~~~~~~~~~~~~~~

[source,ruby]
....
def deliver(from: "A", to: nil, via: "mail")
  "Sending from #{from} to #{to} via #{via}."
end

deliver(to: "B") # => "Sending from A to B via mail."
deliver(via: "Pony Express", from: "B", to: "A") # => "Sending from B to A via Pony Express."
....

[[classes]]
Classes
-------

[source,ruby]
....
class Greeter
  attr_accessor :greeting       # public
  
  def initialize(name = "World", greeting = "Hi")
    @name = name                # private
  end
  def say_hi
    puts "#{greeting} #{@name}!"
  end
  def say_bye
    puts "Bye #{@name}, come back soon."
  end
end

greeter = Greeter.new("Maria")
greeter.say_hi               # Hi Maria!
greeter.say_bye              # Bye Maria, come back soon.
greeter.greeting = "Bonjur"
greeter.say_hi               # Bonjur Maria!
....

Class members can have access modifiers `public` (default), `private` and `protected`, which apply until the end of scope.

Operators can be overloaded.

[source,ruby]
....
class Test
  def identifier
    99
  end

  def ==(other)
    identifier == other.identifier
  end
end
....

In Ruby, you can open a class up again and modify it.
The changes will be present in any new objects you create and in existing objects of that class.

[source,ruby]
....
class Greeter
  attr_accessor :bye
end

greeter.bye = "Chao"
greeter.say_bye # Chao Maria, come back soon.
....

[[per-object-methods]]
Per object methods
~~~~~~~~~~~~~~~~~~

[source,ruby]
....
class Car
  def inspect
    "Cheap car"
  end
end

porsche = Car.new
porsche.inspect # => Cheap car
def porsche.inspect
  "Expensive car"
end

porsche.inspect # => Expensive car

# Other objects are not affected
other_car = Car.new
other_car.inspect # => Cheap car
....

[[missing-methods]]
Missing methods
~~~~~~~~~~~~~~~~~~

Ruby doesn’t give up if it can’t find a method that responds to a particular message. It calls the `method_missing` method with the name of the method it couldn’t find and the arguments. By default, method_missing raises a `NameError` exception, but you can redefine it to better fit your application, and many libraries do.

[source, ruby]
....
def method_missing(id, *arguments)
  puts "Method #{id} was called, but not found. It has " +
       "these arguments: #{arguments.join(", ")}"
end
....

[source,ruby]
....
#!/usr/bin/env ruby

class MegaGreeter
  attr_accessor :names

  # Create the object
  def initialize(names = "World")
    @names = names
  end

  # Say hi to everybody
  def say_hi
    if @names.nil?
      puts "..."
    elsif @names.respond_to?("each")
      # @names is a list of some kind, iterate!
      @names.each do |name|
        puts "Hello #{name}!"
      end
    else
      puts "Hello #{@names}!"
    end
  end

  # Say bye to everybody
  def say_bye
    if @names.nil?
      puts "..."
    elsif @names.respond_to?("join")
      # Join the list elements with commas
      puts "Goodbye #{@names.join(", ")}.  Come back soon!"
    else
      puts "Goodbye #{@names}.  Come back soon!"
    end
  end
end


if __FILE__ == $0
  mg = MegaGreeter.new
  mg.say_hi
  mg.say_bye

  # Change name to be "Zeke"
  mg.names = "Zeke"
  mg.say_hi
  mg.say_bye

  # Change the name to an array of names
  mg.names = ["Albert", "Brenda", "Charles",
              "Dave", "Engelbert"]
  mg.say_hi
  mg.say_bye

  # Change to nil
  mg.names = nil
  mg.say_hi
  mg.say_bye
end
....

[[reflection]]
Reflection
----------

[source,ruby]
....
greeter.instance_methods        # including inherited
greeter.instance_methods(falst) # excluding inherited
greeter.responds_to?("say_hi")  # true
....


[[format-conversion]]
format convertions
------------------
....
to_s
to_i
to_a
....

[[arrays]]
arrays
------

sorting arrays
....
ticket = [34, 32, 43]
ticket.sort! // ticket == [32, 34, 43]
             // exclamation mark means sort in _in place_
             
ticket.reverse! // ticket = [43, 34, 32]
....
