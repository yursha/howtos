- https://www.kernel.org/
- http://tldp.org/LDP/intro-linux/html/index.html
- http://www.thegeekstuff.com/2010/08/how-to-add-swap-space/
- http://distrowatch.com/ - distros, packages, reviews

# Src
- `/usr/src/kernels`

Parameters can be passed to the kernel:
- at compile-time
- at start time via boot loader
- at runtime via `/proc` and `/sys`

- `cat /proc/cmdline` - print to STDOUT parameters the kernel was booted up with.

# LFS
- http://lelandbatey.com/posts/2014/10/building-linux-from-scratch/
- https://duskfire.wordpress.com/2012/05/01/linux-from-scratch-part-one/
- https://www.youtube.com/watch?v=qZJzbI6ZJ34

# Packages

## util-linux
- [util-linux releases](ftp://ftp.kernel.org/pub/linux/utils/util-linux/)
- https://www.archlinux.org/packages/core/x86_64/util-linux/
- ftp://ftp.kernel.org/pub/linux/utils/util-linux/
- `cat /proc/swaps`
- `fallocate` - preallocate or deallocate space to a file
- `mkswap`
- `mkswap /dev/sda2`
- `swapon`, `swapoff`
- `fstrim`
- `dmesg` - prints or controls the kernel ring buffer
- `cal` - calendar
- `rename`
- `write`
- `whereis`
- `chsh` - change user login shell

## procps-ng
- https://gitlab.com/procps-ng/procps
Command line and full screen utilities for browsing procfs, a "pseudo" file system dynamically generated by the kernel to provide information about the status of entries in its process table.
- `/proc/bus/input/devices`
- `ps`
- `ps -ef` - list all running processes verbosely

- `free`

# kmod - Linux kernel module management utilities
- http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git
- http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git/tree/README

Linux kernel is modular, meaning many of the drivers for hardware reside on disk and are available as modules. At boot `udev` takes an inventory of your hardware and loads appropriate modules (drivers) for your corresponding hardware.

Linux kernel modules live in `/lib/modules/$(uname -r)`.

`libkmod` library is used to implement kernel module management utilities.

- `lsmod` - list modules (nicely formatted `cat /proc/modules`)
- `modprobe` - load or unload a module
- `insmod` - load a module (better use `modprobe` because the latter handles dependencies)
- `rmmod` - unload a module (better use `modprobe -r`)
- `modinfo` - show info about a module
- `depmod` - generate `modules.dep` (`man modules.dep`), `modules.symbols` and `modules.devname` and their binary counterparts. Configured through `depmod.d` (`man depmod.d`).
- `kmod` - manage modules (generic binary)

The behavior of `modprobe` (how modules are loaded and unloaded may be configured in `modprobe.d`) (see `man modprobe.d`)

Some wireless chipsets also require firmware, in addition to a driver. Many firmware images are provided by the 'linux-firmware' package.

- Archlinux wiki - kernel modules

# udev - Dynamic device management (`man udev`)
- Archlinux wiki - `udev`

# Misc
- initramfs
- initrd
- mkinitrd
- systemd-tempfiles
- System.map (kernel build artifact)
- Module.symvers (kernel build artifact)
- Kernel Command Line - https://www.freedesktop.org/software/systemd/man/kernel-command-line.html (module options can be specified on it)

# sysfs
- https://en.wikipedia.org/wiki/Sysfs

# ioctl
- https://en.wikipedia.org/wiki/Ioctl

# GPU
- [Linux GPU Driver Developer's Guide](https://www.kernel.org/doc/htmldocs/gpu/index.html)
- [Anatomy of an Embedded KMS driver - Youtube - Embedded Linux Conference 2013](https://www.youtube.com/watch?v=Ja8fM7rTae4)

# framebuffer
- A framebuffer is a portion of RAM containing a bitmap (complete frame of data) that is driven to a video display.

The information in the memory buffer typically consists of color values for every pixel (point that can be displayed) on the screen. Color values are commonly stored in 1-bit binary (monochrome), 4-bit palettized, 8-bit palettized, 16-bit high color and 24-bit true color formats. An additional alpha channel is sometimes used to retain information about pixel transparency. The total amount of the memory required to drive the framebuffer depends on the resolution of the output signal, and on the color depth and palette size.

- page flipping (standard technique by game programmers)

As the demand for better graphics increased, hardware manufacturers created a way to decrease the amount of CPU time required to fill the framebuffer. This is commonly called "graphics accelerating".

Common graphics drawing commands (many of them geometric) are sent to the graphics accelerator in their raw form. The accelerator then rasterizes the results of the command to the framebuffer. This method can save thousands or millions of CPU cycles per command, as the CPU is freed to do other work.

A common design is to send commands to the graphics accelerator using a library such as OpenGL or Direct3D. The graphics driver then translates those commands to instructions for the accelerator's graphics processing unit (GPU). The GPU uses those microinstructions to compute the rasterized results. Those results are bit blitted to the framebuffer. The framebuffer's signal is then produced in combination with built-in video overlay devices (usually used to produce the mouse cursor without modifying the framebuffer's data) and any analog special effects that are produced by modifying the output signal.

- https://en.wikipedia.org/wiki/Bit_blit

What is the status of DirectFB?

# Direct Rendering Manager (DRM)
- `drivers/gpu/drm`
- https://dri.freedesktop.org/wiki/DRM/
- https://en.wikipedia.org/wiki/Direct_Rendering_Manager
- Linux kernel subsystem responsible for interfacing with GPUs. DRM exposes an API that user space programs can use to send commands and data to the GPU, and perform operations such as configuring the mode setting of the display. User space programs can use the DRM API to command the GPU to do hardware accelerated 3D rendering, video decoding as well as GPGPU computing.
- https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units
- https://en.wikipedia.org/wiki/Hardware_acceleration
- https://en.wikipedia.org/wiki/3D_rendering
- https://en.wikipedia.org/wiki/Video_decoder

The Direct Rendering Manager resides in kernel space, so the user space programs must use kernel system calls to request its services. However, DRM doesn't define its own customized system calls. Instead, it follows the Unix principle "everything is a file" to expose the GPUs through the filesystem name space using device files under the /dev hierarchy. Each GPU detected by DRM is referred as a DRM device, and a device file /dev/dri/cardX (where X is a sequential number) is created to interface with it. User space programs that want to talk to the GPU must open the file and use ioctl calls to communicate with DRM. Different ioctls correspond to different functions of the DRM API.

A library called libdrm was created to facilitate the interface of user space programs with the DRM subsystem. This library is merely a wrapper that provides a function written in C for every ioctl of the DRM API, as well as constants, structures and other helper elements.[10] The use of libdrm not only avoids exposing the kernel interface directly to user space, but presents the usual advantages of reusing and sharing code between programs.

DRM consists of two parts: a generic "DRM core" and a specific one ("DRM Driver") for each type of supported hardware.[11] DRM core provides the basic framework where different DRM drivers can register, and also provides to user space a minimum set of ioctls with common, hardware-independent functionality.[8] A DRM driver, on the other hand, implements the hardware-dependent part of the API, specific to the type of GPU it supports; it should provide the implementation of the remaining ioctls not covered by DRM core, but it may also extend the API offering additional ioctls with extra functionality only available on such hardware.[8] When a specific DRM driver provides an enhanced API, user space libdrm is also extended by an extra library libdrm-driver that can be used by user space to interface with the additional ioctls.

## Kernel Mode Setting (KMS)
- Mode setting is a software operation that activates a display mode (screen resolution, color depth, and refresh rate) for a computer's display controller. Wayland compositors (e.g. Weston) and kmscon depend on kernel mode setting via ioctl.

## Graphics Execution Manager (GEM)

# Power
- https://www.kernel.org/doc/Documentation/power/interface.txt

`/sys/power/image_size` controls the size of the image created by the suspend-to-disk mechanism. It can be written a string representing a non-negative integer that will be used as an upper limit of the image size, in bytes. The suspend-to-disk mechanism will do its best to ensure the image size will not exceed that number. However, if this turns out to be impossible, it will try to suspend anyway using the smallest image possible. In particular, if "0" is written to this file, the suspend image will be as small as possible. Reading from this file will display the current image size limit, which is set to 2/5 of available RAM by default.

## pm-utils
- `pm-utils` - http://pm-utils.freedesktop.org/wiki/
- `pm-utils` - Utilities and scripts for suspend and hibernate power management
- `/sys/power` directory - https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-power
- `s2disk`

## misc
- How `/dev/zero` and `/dev/null` work?
- http://www.tldp.org/LDP/khg/HyperNews/get/khg.html

# Linux Torvalds
- http://yarchive.net/comp/linux/everything_is_file.html
- https://www.quora.com/What-does-Linus-Torvalds-think-of-Java-and-the-JVM

# System calls
- Section 2 of the man pages describes system calls (kernel interface)
- `man 2 intro`
- `man syscalls`
- [Syscalls Table by Filippo Valsorda](https://filippo.io/linux-syscall-table/)
- [Syscalls Table by Ryan Chapman](http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64)
- [Linux syscalls](http://cs.lmu.edu/~ray/notes/linuxsyscalls/)
- [Source code for `open` syscall](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/open.c)

# ifconfig

# Misc
- magic ioctl

- https://doc.opensuse.org/documentation/html/openSUSE_121/opensuse-tuning/index.html

# Sort me out
- `killall`

# Firmware
- https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/

Firmware lives in `/lib/firmware`

## PCI
- `/usr/include/linux/pci.h`

### `pciutils` - mj.ucw.cz/sw/pciutils
- `lspci` - list all PCI hardware
- `lspci -k` - list all PCI hardware with kernel modules handling them.
- `lspci | grep VGA` - find out graphics chip. Intel chips only need `xf86-video-intel` archlinux package.

## USB
### `usbutils` - linux-usb.sourceforge.net
- `lsusb`

## ACPI
- https://www.kernel.org/doc/Documentation/power/states.txt

The kernel supports `freeze`(s0), `standby` (s1), `mem` (s3) and `disk`(s4) sleep states that can be read or written to the `/sys/power/state` file.  `disk` represents hibernation and the meaning of the remaining ones depends on the `relative_sleep_states` command line argument. For `disk`, a mechanism called `swsusp` (Swap Suspend) is used
to write memory contents to free swap space. Some, albeit outdated, documentation can be found in `Documentation/power/swsusp.txt`. Alternatively, userspace can do most of the actual suspend to disk work,
see `userland-swsusp.txt`.

- `cat /sys/power/state` - print supported power states.


# BIOS
- https://en.wikipedia.org/wiki/BIOS
- `lrmi` - Linux Real Mode Interface - http://sourceforge.net/projects/lrmi/ - library for calling real mode BIOS routines under Linux.
- `vbetool` - http://manpages.ubuntu.com/manpages/hardy/man1/vbetool.1.html - runs real-mode video BIOS code to alter hardware state. Uses `lrmi` in order to run code from the video BIOS. Currently, it is able to alter DPMS states, save/restore video card state and attempt to initialize the video card from scratch. 
- Display Power Management Signaling (DPMS) 
  + http://www.tldp.org/HOWTO/Battery-Powered/displaytypes.html
  + https://en.wikipedia.org/wiki/VESA_Display_Power_Management_Signaling
  + http://www.webopedia.com/TERM/D/DPMS.html
  + http://www.x.org/releases/X11R7.7/doc/libXext/dpmslib.html
  + http://www.x.org/releases/X11R7.7/doc/xextproto/dpms.html
  
## VESA BIOS Extensions
- https://en.wikipedia.org/wiki/VESA_BIOS_Extensions

Standard interface that can be used by software to access compliant video boards at high resolutions and bit depths. This is opposed to the "traditional" int 10h BIOS calls, which are limited to resolutions of 640x480 pixels with 16 color (4-bit) depth or less. VBE is made available through the video card's BIOS, which installs during boot up some interrupt vectors that point to itself.

## BIOS Interrupt Call
- https://en.wikipedia.org/wiki/INT_10H
- https://en.wikipedia.org/wiki/BIOS_interrupt_call

# UEFI
- https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface

# CPU
## Interrupts
- FLIH (First Level Interrupt Handler) - upper half
- SLIH (Second Level Interrupt Handler) - bottom half
- Jonathan Corbet; Alessandro Rubini; Greg Kroah-Hartman (January 27, 2005). "Linux Device Drivers, Chapter 10. Interrupt Handling" http://static.lwn.net/images/pdf/LDD3/ch10.pdf
-  "The Linux Kernel Module Programming Guide, Chapter 12. Interrupt Handlers" - http://www.tldp.org/LDP/lkmpg/2.6/html/x1256.html

# Wireless
## Broadcom source files
- http://lxr.free-electrons.com/source/drivers/net/wireless/brcm80211/brcmfmac/firmware.c
- http://lxr.free-electrons.com/source/drivers/net/wireless/brcm80211/brcmfmac/pcie.c

# Memory

## Paging

# Disk

## Partitioning
- `fdisk`
- `cfdisk`

## Trim
- https://clusterbuffer.wordpress.com/2011/10/02/how-do-you-know-trim-is-working-with-your-ssd-in-your-system/
- http://blog.neutrino.es/2013/howto-properly-activate-trim-for-your-ssd-on-linux-fstrim-lvm-and-dmcrypt/

### Swap Partition (type 82)
Used for swapping pages of memory between disk and RAM. Used for 'suspend-to-disk' power state.

Linux divides its physical RAM (random access memory) into chunks of memory called pages. Swapping is the process whereby a page of memory is copied to the preconfigured space on the hard disk, called swap space, to free up that page of memory. The combined sizes of the physical memory and the swap space is the amount of virtual memory available.

There is no performance advantage to either a contiguous swap file or a partition, both are treated the same way.

- https://wiki.archlinux.org/index.php/swap
- http://www.linux.com/news/software/applications/8208-all-about-linux-swap-space


# Boot Loaders
- https://wiki.archlinux.org/index.php/Syslinux
- https://wiki.archlinux.org/index.php/Systemd-boot
- https://wiki.archlinux.org/index.php/GRUB
- https://wiki.archlinux.org/index.php/GRUB_Legacy
- https://wiki.archlinux.org/index.php/LILO
- https://wiki.archlinux.org/index.php/REFInd

## GPT
- https://developer.apple.com/library/mac/technotes/tn2166/_index.html

# `/proc` file system

# Video
- `xrandr`

## Switch between different terminals
- `CTRL+ALT+FN+F1`, `CTRL+ALT+FN+F2` etc.

# Camera
- https://github.com/patjak/bcwc_pcie/wiki/Get-Started
- https://bugzilla.kernel.org/show_bug.cgi?id=711311
- https://wiki.archlinux.org/index.php/MacBookPro11,x#Web_cam

# Uptime
- http://unix.stackexchange.com/questions/131775/how-long-has-my-linux-system-been-running

## RHEL
- https://access.redhat.com/documentation/en/
- https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/index.html
- [RHEL 7 System Administator's Guide](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/)
- [RHEL 7 Storage Administration Guide](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/index.html)
- [RHEL 7 Security Guide](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/index.html)

## CentOS

## Fedora
- https://getfedora.org/
- https://docs.fedoraproject.org/en-US/index.html
- https://github.com/developer-portal
- https://fedoraproject.org/wiki/Fedora_Project_Wiki
- https://github.com/FedoraKDE
- https://github.com/fedora-cloud
- https://github.com/fedora-selinux
- https://github.com/fedora-infra
- https://github.com/fedora-python
- https://github.com/fedora-haskell
- https://github.com/fedora-ruby
- https://github.com/fedoradesign
- https://fedoraproject.org/wiki/Design
- [`setup`](https://fedorahosted.org/setup/) - A set of system configuration and setup files
    + `/etc/hosts`

# Debian Family

## Ubuntu
- https://github.com/ubuntu
- https://github.com/Ubuntu-Solutions-Engineering
- https://github.com/ubuntudesign
- https://github.com/ubuntu-touchCAF
- https://github.com/UBTC
- https://github.com/ubuntu-core

## Debian
- https://github.com/Debian
- https://github.com/debian-live
- https://github.com/debian-pkg-android-tools
- https://github.com/jbouse-debian
- https://github.com/debian-pi

# FreeBSD
- https://github.com/freebsd
- https://github.com/chef-cookbooks/freebsd

