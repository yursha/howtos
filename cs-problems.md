# Methods
- dynamic programming
- divide and conquer
- greedy algorithms

# Complexity
- asymptotic complexity (worst case)
- amortized compexity
    + aggregate analysis
    + banking method

# Count something
- create a hash table and increment values as we encounter keys

# Process file
- if it doesn't fit into memory process it line by line in a streaming fashion

# Scalable hash table on disk (in terms of memory) (like for a problem to show the most popular words in a an unlimited stream of words)
- sql database with a table 'KEY,VALUE' where KEY is primary key (unique and indexed) (can be further optimized with in-memory cache of most popular items).

# Combinatorial Search
- https://en.wikipedia.org/wiki/Combinatorial_search
- https://www.cs.princeton.edu/~rs/AlgsDS07/24CombinatorialSearch.pdf
- http://www.cs.cmu.edu/afs/cs/project/jair/pub/volume4/hogg96a-html/node2.html
- http://cs.stackexchange.com/questions/13663/what-is-the-difference-between-exhaustive-search-combinatorial-search

## N Queens
- https://en.wikipedia.org/wiki/Eight_queens_puzzle
- http://stackoverflow.com/questions/3209165/need-help-with-n-queens-program-checking-diagonals
- http://stackoverflow.com/questions/4883118/8-queens-problem
- http://stackoverflow.com/questions/6337765/8-queens-problem-using-backtracking-recurison

# The Water Pouring Problem
- Breadth-firsth search

# Infinite Stream of Prime Numbers

# Greatest Common Divisor

# Least Common Multiple
